"""Provide the utilities used to implement the rest of the package."""
import os
import typing
from dataclasses import dataclass

import gmxapi

from scalems_workshop._abc import Future
from scalems_workshop._abc import PlaceHolder


@dataclass(frozen=True)
class OutputFilePlaceholder(PlaceHolder[str]):
    """Annotation type declaring a file that will be generated by a Task."""
    filename: typing.Optional[str]
    label: typing.Optional[str]
    suffix: typing.Optional[str]

    # Note that the initial definition is for a stateless object. We could consider
    # a stateful object that acquires a reference to the Future that will produce
    # the output file:
    # future: Future = None  # Reference to the Future that delivers the output file, once established.
    #
    # We could also add behaviors to allow OutputFilePlaceholder to learn its
    # Path and deliver the appropriate string when referenced. However, we will
    # try to keep things simple while we can. We will rely on separate machinery
    # to replace instances of OutputFilePlaceholder with appropriate values
    # where needed.


class _MonotonicInteger:
    __value = -1

    @staticmethod
    def get():
        _MonotonicInteger.__value += 1
        return _MonotonicInteger.__value


def get_path(placeholder: OutputFilePlaceholder) -> str:
    """

    Returns:
        str: an appropriate filename
    """
    if placeholder.filename:
        path: str = placeholder.filename
    else:
        if placeholder.label:
            path = placeholder.label
        else:
            path = 'output'
        path += str(_MonotonicInteger.get())
        if placeholder.suffix:
            path += placeholder.suffix
    return path


def output_file(filename: typing.Union[str, Future] = None, *,
                label: str = None, suffix: str = None):
    """Declare an output file.

    When used in a string context (e.g. a `executable` *argv* element),
    the *output_file* placeholder is automatically converted to the full
    output file path.

    If *filename* is not provided, a suitable filename is generated (optionally
    constrained by *suffix*, if provided).

    If *filename* is a relative path, it will be expanded relative to the Task
    working directory.

    If *filename* already exists, behavior is determined by the tool supporting
    the Task.

    If *label* is unspecified, the *filename* is used as the output key.
    """
    if filename is not None and not isinstance(filename, str):
        try:
            # noinspection PyTypeChecker
            filename = str(os.fspath(filename), encoding='utf8')
        except TypeError:
            raise ValueError('filename must be a str or None.')
    if label is not None and not isinstance(label, str):
        raise ValueError('label must be a str or None.')
    if suffix is not None and not isinstance(suffix, str):
        raise ValueError('suffix must be a str or None.')
    if suffix and filename is not None:
        raise ValueError('A suffix may only be requested when *filename* is unspecified.')
    return OutputFilePlaceholder(filename=filename, label=label, suffix=suffix)


def function_wrapper(*args, **kwargs):
    return gmxapi.function_wrapper(*args, **kwargs)
