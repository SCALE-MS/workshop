"""Provide the utilities used to implement the rest of the package."""
import os
import typing
from dataclasses import dataclass

import gmxapi

from scalems_workshop._abc import Future
from scalems_workshop._abc import PlaceHolder
from ._abc import getattr_proxy
from ._abc import Reference


@dataclass(frozen=True)
class OutputFilePlaceholder(PlaceHolder[str]):
    """Annotation type declaring a file that will be generated by a Task."""
    filename: typing.Optional[str]
    label: str
    suffix: typing.Optional[str]

    # Note that the initial definition is for a stateless object. We could consider
    # a stateful object that acquires a reference to the Future that will produce
    # the output file:
    # future: Future = None  # Reference to the Future that delivers the output file, once established.
    #
    # We could also add behaviors to allow OutputFilePlaceholder to learn its
    # Path and deliver the appropriate string when referenced. However, we will
    # try to keep things simple while we can. We will rely on separate machinery
    # to replace instances of OutputFilePlaceholder with appropriate values
    # where needed.


class _MonotonicInteger:
    __value = -1

    @staticmethod
    def get():
        _MonotonicInteger.__value += 1
        return _MonotonicInteger.__value


def get_path(placeholder: OutputFilePlaceholder) -> str:
    """Get an actual path from a deferred operation or path placeholder.

    Returns:
        str: an appropriate filename
    """
    if placeholder.filename:
        path: str = placeholder.filename
    else:
        if placeholder.label:
            path = placeholder.label
        else:
            path = 'output'
        path += str(_MonotonicInteger.get())
        if placeholder.suffix:
            path += placeholder.suffix
    return path


def output_file(filename: typing.Union[str, Future] = None, *,
                label: str = None, suffix: str = None):
    """Declare an output file.

    When used in a string context (e.g. a `executable` *argv* element),
    the *output_file* placeholder is automatically converted to the full
    output file path.

    If *filename* is not provided, a suitable filename is generated (optionally
    constrained by *suffix*, if provided).

    If *filename* is a relative path, it will be expanded relative to the Task
    working directory.

    If *filename* already exists, behavior is determined by the tool supporting
    the Task.

    If *label* is unspecified, the *filename* is used as the output key.
    """
    if not label and not filename:
        raise TypeError('Either *label* or *filename* must be provided.')
    if filename is not None and not isinstance(filename, str):
        try:
            # noinspection PyTypeChecker
            filename = str(os.fspath(filename), encoding='utf8')
        except TypeError:
            raise ValueError('filename must be a str or None.')
    if label is not None and not isinstance(label, str):
        raise ValueError('label must be a str or None.')
    if suffix is not None and not isinstance(suffix, str):
        raise ValueError('suffix must be a str or None.')
    if suffix and filename is not None:
        raise ValueError('A suffix may only be requested when *filename* is unspecified.')
    if not label:
        label = filename
    return OutputFilePlaceholder(filename=filename, label=label, suffix=suffix)


class ResultProxy(Reference):
    """Proxy access to the result of a non-scalems command.
    """

    def __init__(self, func: typing.Callable, args: tuple, kwargs: dict):
        # Record the details of the task supporting the node.
        self.func = func
        self.args = args
        self.kwargs = kwargs
        # We pick up the name during Subgraph.__set_name__() once the namespace is populated.
        self.key = ''

    def __getattr__(self, item):
        # Proxy attribute access to something that can be instantiated during translation to
        # gmxapi.subgraph.
        return getattr_proxy(self, item)


class _WrappedFunctionProxy:
    _wrapper_args: tuple
    _wrapper_kwargs: dict
    _wrapped_function: typing.Callable

    def __init__(self, func: typing.Callable, args: tuple, kwargs: dict):
        self._wrapper_args = args
        self._wrapper_kwargs = kwargs
        self._wrapped_function = func

    def __call__(self, *args, **kwargs):
        # gmxapi.function_wrapper(*self._wrapper_args, **self._wrapper_kwargs)(self._wrapped_function)(
        # *args, **kwargs)
        return ResultProxy(
            func=gmxapi.function_wrapper(*self._wrapper_args, **self._wrapper_kwargs)(self._wrapped_function),
            args=args,
            kwargs=kwargs
        )


class _FunctionWrapperDecorator:
    def __init__(self, *args, **kwargs):
        self._wrapper_args = args
        self._wrapper_kwargs = kwargs

    def __call__(self, func: typing.Callable):
        return _WrappedFunctionProxy(func, self._wrapper_args, self._wrapper_kwargs)


def function_wrapper(*args, **kwargs):
    """Decorate a function for use as a workflow operation.

    See gmxapi.commandline_operation() for details of the (currently proxied) functionality and usage.
    """
    if len(kwargs) == 0 and len(args) == 1 and callable(args[0]):
        # Assume decorator was used without parameters: `@function_wrapper def myfunc(): ...`
        decorator = _FunctionWrapperDecorator()
        return decorator(args[0])
    else:
        decorator = _FunctionWrapperDecorator(*args, **kwargs)
        return decorator
